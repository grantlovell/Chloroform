{"name":"Chloroform","tagline":"a jQuery-based client-side form validation plugin","body":"# Chloroform\r\n\r\nChloroform is the best jQuery-based client-side form validation plugin. There are lots of other ones. Some are good, others are horrid. This one is much better than most, and slightly awesomer than the second best. It's simple to use, easy to customize, highly extensible, and very efficient.\r\n\r\n\r\n## Get Started\r\n\r\nOf course, you need to include the Chloroform script and stylesheet in your head. You need jQuery too.\r\n\r\n\t\t<script src=\"path_to_jquery\"></script>\r\n\t\t<script src=\"chloroform.js\"></script>\r\n\t\t<link rel=\"stylesheet\" href=\"chloroform.css\" />\r\n\r\nYou also need to execute Chloroform on a form element. For best results, do this in a ready() callback.\r\n\r\n\t\t<script>\r\n\t\tjQuery(document).ready(function($) {\r\n\t\t\t$('#myform').chloroform();\r\n\t\t});\r\n\t\t</script>\r\n\t\t\r\n\t\t<form id=\"myform\">\r\n\t\tetc.\r\n\t\t\r\nThere are a bunch of options you can pass in to the chloroform() method, but we'll look at those later.\r\n\r\n## Your First Validation with Chloroform\r\n\r\nTo add form validation to your form elements, just add an attribute named \"data-validate\", with special rule names in it like \"required\" and \"length\".\r\n\r\nFor example, the field \"myfield\" below has a validation rule named \"required\". It must not be empty.\r\n\r\n\t<form id=\"myform\">\r\n\t<input id=\"myfield\" type=\"text\" value=\"\" data-validate=\"required\"/>\r\n\t<input type=\"submit\" value=\"Save\"/>\r\n\t</form>\r\n\r\n### Using Rules\r\n\r\nA \"rule\" is a criterium that the value of a form element must fulfil, before it can be deemed valid. In reality, it's a javascript function that returns true or false.\r\n\r\nThe rules are named. They have names like \"numeric\" and \"required\". To apply a rule to an HTML form element, you add its name to the data-validate attribute, like the example above.\r\n\r\n### Multiple Rules\r\n\r\nTo add multiple rules to the same form element, separate the rule names with a comma.\r\n\r\n\t<form id=\"myform\">\r\n\t<input id=\"myfield\" type=\"text\" value=\"123\" data-validate=\"required,email\"/>\r\n\t<input type=\"submit\" value=\"Save\"/>\r\n\t</form>\r\n\r\nThe logic operator binding multiple rules is \"AND\". In order for a form element to be valid, it must obey all the rules. In the example above, the form element must be not-empty (required) AND it must also look like an email address.\r\n\r\nIf you have unusual validation rules that require something like an \"OR\" or some other logical operation, then you just need to create a custom rule. Which is easy to do.\r\n\r\n\r\n### Inverting Validation with \"!\"\r\n\r\nTo indicate that an element should be valid when a rule does NOT pass, precede the rule name with a !.\r\n\r\nFor example, this element will be valid if the value is NOT an integer.\r\n\r\n\t<input type=\"text\" id=\"field\" data-validate=\"!integer\" value=\"3.141\"/>\r\n\r\nYou can do interesting things with this. For example, to prevent people from putting an email address into a username field, you could explicitly put a NOT email rule on it:\r\n\r\n\t<input type=\"text\" id=\"username\" data-validate=\"!email\" value=\"\"/>\r\n\r\nYou could also prevent words from being present in the value, by putting a NOT operator on the \"contains\" rule:\r\n\r\n\t<input type=\"text\" id=\"username\" data-validate=\"!contains[badword]\" value=\"\"/>\r\n\r\n\r\n### Rules with Arguments\r\n\r\nSome require arguments. For example, the \"length\" rule takes either one or two arguments. Arguments are expressed in square brackets, separated by a colon.\r\n\r\nFor example, the field \"myfield\" below must be between 6 and 16 characters.\r\n\r\n\t<form id=\"myform\">\r\n\t<input id=\"myfield\" type=\"text\" value=\"123\" data-validate=\"length[6:16]\"/>\r\n\t<input type=\"submit\" value=\"Save\"/>\r\n\t</form>\r\n\r\n### Built-In Rules\r\n\r\nChloroform comes with an excellent collection of pre-rolled rules. Here are some that are defined in version 1.0:\r\n\r\n* required\r\n* equals\r\n* sameas\r\n* alpha\r\n* numeric\r\n* integer\r\n* max\r\n* min\r\n* between\r\n* length\r\n* choices\r\n* contains\r\n* regex\r\n* email\r\n* url\r\n\r\nIt's a pretty solid collection of standard, well-written, optimized rules. But Chloroform doesn't end there - it's easy to write your own custom rules, too.\r\n\r\n### Custom Rules\r\n\r\nA custom rule is a named function that you write in the global scope. The function must adhere to these criteria:\r\n\r\n* the first argument is the element being validated, preselected as a jQuery object so you can use methods like element.val()\r\n* the second argument the \"not\" boolean, indicating if the rule is being applied normally, or inverted. Depending on the behaviour of the rule, this may mean just the difference between a pass or fail, but it may also change the error message being returned.\r\n* the return value should be an object with one member named \"valid\". If valid is false, then a second member named \"message\" contains the error message to be displayed to the user.\r\n\r\nHere's a good, simple example:\r\n\r\n\tfunction custom1(element,not){\r\n\t\tif (element.val() == \"123\"){\r\n\t\t\treturn {'valid':true}\r\n\t\t} else {\r\n\t\t\treturn {'valid':false,'message':'dude, that\\'s not right.'}\r\n\t\t}\r\n\t}\r\n\r\nThis form element uses the custom1 rule:\r\n\r\n\t<input type=\"text\" id=\"field6\" data-validate=\"custom1\" value=\"123\"/>\r\n\r\nIt's that easy! If your data-validate attribute contains a name, Chloroform will look for a function with that name in the global scope. \r\n\r\nHere's one that's a little more complex, showing how the wording of the error message is altered by the \"not\" inversion. It also takes a third argument:\r\n\r\n\tfunction maximum(elem,not,max){\r\n\t\tvar val = parseFloat($(elem).val());\r\n\t\tif (val > max){\r\n\t\t\treturn not?{'valid':true}:{'valid':false,'message':'this must be less than '+max};\r\n\t\t}\r\n\t\treturn not?{'valid':false,'message':'this must not be less than '+max}:{'valid':true};\r\n\t}\r\n\r\nThis rule would be applied to this form element. Notice the parameter in square brackets, which is ultimately passed along as the third argument of the maximum() function.\r\n\r\n\t<input type=\"text\" id=\"field7\" data-validate=\"maximum[5]\" value=\"123\"/>\r\n\r\n\r\n## Chloroform Options\r\n\r\n\r\n\r\nYou can customize how chloroform behaves by defining a whole bunch of useful options.\r\n\r\n\t<script>\r\n\t\tjQuery(document).ready(function($) {\r\n\t\t\t$('#myform').chloroform({\r\n\t\t\t\tlang: 'en', \t\t\t\t\t\t\t// default language - i18n has not been implemented yet\r\n\t\t\t\tvalidateDataAttr: 'data-validate', \t\t// name of the attribute which stores what validation rules to apply\r\n\t\t\t\tscrollToBubble: true,\t\t\t\t\t// if true, then the error bubble popup will scroll into view.\r\n\t\t\t\t\r\n\t\t\t\t// callback functions\r\n\t\t\t\tonBeforeValidateAll: function(){\r\n\t\t\t\t\t// do something before a validateAll action\r\n\t\t\t\t},\r\n\t\t\t\tonAfterValidateAll: function(){\r\n\t\t\t\t\t// do something after a validateAll action\r\n\t\t\t\t},\r\n\t\t\t\tonBeforeValidate:function(){\r\n\t\t\t\t\t// do something before a validate action\r\n\t\t\t\t},\r\n\t\t\t\tonAfterValidate:function(){\r\n\t\t\t\t\t// do something after a validate action\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t</script>\r\n\r\n## Options\r\n\r\n### lang\r\nat this time, i18n is not implemented. The \"lang\" option is reserved for use as a language identifier.\r\n\r\n### validateDataAttr\r\nthis is the attribute that will be used to register validation rules. By default it's \"data-validate\", but you can change that.\r\n\r\n### scrollToBubble\r\nif true, then the error bubble popup will scroll into view when it appears, with an animated \"smooth scroll\".\r\n\r\n## Callback Functions\r\n\r\n### onBeforeValidateAll()\r\nreturns boolean\r\n\r\nif onBeforeValidateAll returns false, the validation is aborted and validateAll() returns false, and the submit event that triggered the validation is aborted. \r\nif onBeforeValidateAll returns true, then validation proceeds normally. \r\nUse this to prevent the validation from continuing based on some other factor which may invalidate the entire form.\r\n\r\n### onAfterValidateAll(bool allPassed)\r\nHas one argument, indicating if all the validation rules passed. If onAfterValidateAll returns true, then submission proceeds normally. If onAfterValidateAll returns false, then submission is stopped. \r\nUse this callback to hook in additional behaviour to the form, for example to control the disabled state of the submit button if the form isn't filled out correctly.\r\n\r\n### onBeforeValidate()\r\nreturns boolean\r\nthis callback is triggered immediately before any validation begins on an element. If many elements are being validated, then this function will be called once for each element.\r\nIf this function returns false, then the validation will fail and abort.\r\n\r\n### onAfterValidate(bool passed)\r\nreturns boolean\r\nthis callback is triggered immediately after all the validation rules are finished on an element. The argument passed into onAfterValidate() is whether the rules passed or failed.\r\nIf this function returns false, then validation fails and aborts.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Chloroform Object Architecture\r\n\r\nChloroform achieves its validation by saving an object in the \"data\" property of each form element. This object doesn't just describe how the element should be validated - it actually contains the functions that are executed, when triggered by Chloroform's form handlers.\r\n\r\nThe plugin defines an array of elements. Each element has two data elements: rules and arguments.\r\nFor example, the plugin <i>elements</i> array might contain: [field1,field2,field3]. Each element in the array is a jQuery object, as would be returned from a jQuery selector like $('#field1').\r\n\r\nThe validation rules applied to each element are stored in its data object. The rules inhabit two named objects in the element's data: rules and arguments.\r\n\r\n#### element.data('rules')\r\n\r\nelement.data('rules') is an object - used like a named associative array - of functions. Each function is named, and doesn't matter if it's one of Cholroform's built-in preset functions, or a custom one.\r\nWhen expressed as JSON, the data('rules') object will look like this:\r\n\r\n\t{\r\n\t\t'notafive':function(){\r\n\t\t\tvar elem = arguments[0];\r\n\t\t\tvar not = arguments[1];\r\n\t\t\tvar val = parseFloat($(elem).val());\r\n\t\t\tif (val != 5){\r\n\t\t\t\treturn {'valid':false,'message':'this is not a five'};\r\n\t\t\t}\r\n\t\t\treturn {'valid':true};\r\n\t\t},\r\n\t\t'max':function()\r\n\t\t\tvar elem = arguments[0];\r\n\t\t\tvar not = arguments[1];\r\n\t\t\tvar val = parseFloat($(elem).val());\r\n\t\t\tvar max = parseFloat(arguments[2]);\r\n\t\t\tif (val > max){\r\n\t\t\t\treturn {'valid':false,'message':'this must be less than '+max};\r\n\t\t\t}\r\n\t\t\treturn {'valid':true};\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\r\nAll rules accept <i>element</i> as their first argument, and <i>not</i> as their second. Some accept more additional arguments. The return value of a rule function is strict, as will be explained below.\r\n\r\n#### element.data('arguments')\r\n\r\nelement.data('arguments') is an object - again, used like an associative array - of argument arrays. Rules that require extra arguments store those arguments here.\r\nThe data('arguments') object is used to hold the arguments for those rule functions that accept them. For example, one of your rules might be 'length', which accepts the arguments (min,max). If your element validates when the length is between 5 and 16, then the value of data('arguments') will be:\r\n\r\n\t{\r\n\t\t'length':[5,16]\r\n\t}\r\n\r\nBy manipulating the data('arguments') object, you can change the parameters of a validation rule without having to change the rule itself. Arguments are populated automatically when you add arguments in square brackets in the data-validate attribute, eg: \"length[5:16]\"\r\nWhen manipulating the arguments object, it is important to remember that every array in arguments must have a function of the same name in rules. The array of values must correspond - in the correct order - to the arguments expected by the corresponding rule function.\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}